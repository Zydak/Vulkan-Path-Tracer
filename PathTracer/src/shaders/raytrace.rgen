#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_scalar_block_layout : enable

#include "raycommon.glsl"

layout(set = 1, binding = 2) readonly buffer uEnvMapAccel
{
    EnvAccel[] uAccels;
};
layout(push_constant) uniform _PushConstantRay { PushConstantRay push; };

#include "Sampling.glsl"

layout(location = 0) rayPayloadEXT hitPayload payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;
layout(set = 0, binding = 8) buffer DOFUniform { float uDof; };
layout(set = 0, binding = 12, scalar) buffer Volumes { Volume uVolumes[]; };
layout(set = 1, binding = 0) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(set = 1, binding = 1) uniform sampler2D uEnvMap;

layout(set = 0, binding = 14, rgba32f) uniform image2D uGBufferAlbedo;
layout(set = 0, binding = 15, rgba32f) uniform image2D uGBufferNormal;

void main()
{
    uint seed = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x + int(clockARB());
    payload.Seed = PCG(seed);

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.00001f;
    float tMax     = 10000.0f;

    vec3 finalHitValue = vec3(0);

    payload.HitValue = vec3(0.0);
    payload.Depth = 0;
    payload.Weight = vec3(0.0);
    payload.MissedAllGeometry = false;

    if (gl_LaunchIDEXT.xy == (gl_LaunchSizeEXT.xy / 2))
    {
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec4 origin    = uni.ViewInverse * vec4(0, 0, 0, 1);
        vec4 target    = uni.ProjInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = vec3(uni.ViewInverse * vec4(normalize(target.xyz), 0.0f));

        rayQueryEXT query;
		rayQueryInitializeEXT(query, topLevelAS, rayFlags, 0xFF, origin.xyz, tMin, direction, tMax);
		rayQueryProceedEXT(query);
		if (rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT)
		{
			uDof = rayQueryGetIntersectionTEXT(query, true);
		}
    }

    // -------------------------------------------------------------------------------------------------------
    // Fill GBuffer

    if (push.Frame == 0)
    {
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec4 origin    = uni.ViewInverse * vec4(0, 0, 0, 1);
        vec4 target    = uni.ProjInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = vec3(uni.ViewInverse * vec4(normalize(target.xyz), 0.0f));

        traceRayEXT(
            topLevelAS,         // acceleration structure
            rayFlags,           // rayFlags
            0xFF,               // cullMask
            0,                  // sbtRecordOffset
            0,                  // sbtRecordStride
            0,                  // missIndex
            origin.xyz,             // ray origin
            tMin,               // ray min range
            direction,          // ray direction
            tMax,               // ray max range
            0                   // payload (location = 0)
        );

        imageStore(uGBufferAlbedo, ivec2(gl_LaunchIDEXT.xy), vec4(payload.SurfaceAlbedo, 1.f));
        imageStore(uGBufferNormal, ivec2(gl_LaunchIDEXT.xy), vec4((payload.SurfaceNormal + 1.0f) * 0.5f, 1.f));
    }

    // -------------------------------------------------------------------------------------------------------

    vec3 curWeight = vec3(1);
    vec3 hitValue  = vec3(0);

    int samplesAccumulated = 0;
    
    const vec3 camRight = vec3(uni.ViewInverse[0][0], uni.ViewInverse[1][0], uni.ViewInverse[2][0]);
    const vec3 camUp = vec3(uni.ViewInverse[0][1], uni.ViewInverse[1][1], uni.ViewInverse[2][1]);
    for (int i = 0; i < push.SamplesPerFrame; i++)
    {
        vec2 antiAliasingJitter = RandomPointInSquare(payload.Seed) * 0.5f;

        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + antiAliasingJitter;
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec4 origin    = uni.ViewInverse * vec4(0, 0, 0, 1);
        vec4 target    = uni.ProjInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = vec3(uni.ViewInverse * vec4(normalize(target.xyz), 0.0f));

        payload.RayOrigin = origin.xyz;
        payload.RayDirection = direction;

        samplesAccumulated++;
        ivec2 outputImageSize = imageSize(image);
        payload.HitValue = vec3(0.0);
        payload.Depth = 0;

        vec3 focalPoint = origin.xyz + direction * push.FocalLenght;
        vec2 jitter = RandomPointInCircle(payload.Seed) * push.DoFStrenght / 500.0f;
        payload.RayOrigin = origin.xyz + camRight * jitter.x + camUp * jitter.y;

        payload.RayDirection = normalize(focalPoint - payload.RayOrigin);

        payload.Weight = vec3(0.0);
        payload.InMedium = false;

        vec3 curWeight = vec3(1);
        vec3 hitValue  = vec3(0);

        for(; payload.Depth < push.MaxDepth; payload.Depth++)
        {
            float closestScatterDistanceFromCamera = FLT_MAX;
            vec3 finalColor = vec3(0.0f);
            float finalG = 0.0f;
            float finalNullCollision = 0.0f;
            float finalSigmaT = 0.0f;
            float finalPathLengthThroughVolume = 0.0f;
            float finalVolumeWidth = 0.0f;

            // Check at what distance the closest geometry is
            float closestGeometry = -1.0f;
            rayQueryEXT query;
		    rayQueryInitializeEXT(query, topLevelAS, rayFlags, 0xFF, payload.RayOrigin, tMin, payload.RayDirection, tMax);
		    rayQueryProceedEXT(query);
		    if (rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT)
		    {
		        closestGeometry = rayQueryGetIntersectionTEXT(query, true);
		    }

            vec3 dirToLight;
            vec3 randVal = vec3(Rnd(payload.Seed), Rnd(payload.Seed), Rnd(payload.Seed));
            vec4 envColor = SampleImportanceEnvMap(uEnvMap, randVal, dirToLight);
            bool canHit = true;

            // Iterate through all volumes
            for (int i = 0; i < push.VolumesCount; i++)
            {
                Volume volume = uVolumes[i];

                // Check collision positions with volume
                vec3 hitPosNear;
                vec3 hitPosFar;
                IntersectRayAABB(payload.RayOrigin, payload.RayDirection, volume.Aabb, hitPosNear, hitPosFar);
            
                bool isInside = IsInsideAABB(payload.RayOrigin, volume.Aabb);
                if (isInside)
                    hitPosNear = payload.RayOrigin;

                float volumeWidth = length(hitPosFar - hitPosNear);

                // Calculate distance from the camera to the volume intersections
                float volumeNear = -1.0f;
                float volumeFar = -1.0f;
                if (hitPosNear != vec3(-1.0f))
                {
                    volumeNear = length(hitPosNear - payload.RayOrigin);
                }
                if (hitPosFar != vec3(-1.0f))
                {
                    volumeFar = length(hitPosFar - payload.RayOrigin);
                }

                // Calculate overall ray path length through the volume
                float pathLengthThroughVolume = 0.0f;
                if (volumeNear != -1.0f && closestGeometry != -1.0f)
                {
                    // Geometry is in front of the volume
                    if (volumeNear > closestGeometry)
                    {
                        pathLengthThroughVolume = 0.0f;
                    }
            
                    // Geometry is splitting the volume
                    else if (volumeFar > closestGeometry)
                    {
                        pathLengthThroughVolume = closestGeometry - volumeNear;
                    }
                
                    // Volume is in front of the geometry
                    else if (volumeFar < closestGeometry)
                    {
                        pathLengthThroughVolume = volumeWidth;
                    }
                }
                else if (closestGeometry == -1.0f && volumeNear != -1.0f) // Volume in front of the geometry since there is no geometry
                {
                    pathLengthThroughVolume = volumeWidth;
                }

                // Heterogenous volumes:
                //float noise = cnoise(payload.RayOrigin + (volumeNear * payload.RayDirection));
                //noise = clamp(noise, 0.0f, 1.0f);
                //float sigmaT = noise * volume.ScatteringCoefficient;
                //float nullCollision = (1.0f - noise) * volume.ScatteringCoefficient;

                float sigmaT = volume.ScatteringCoefficient;

                float nullCollision = 0.0f;
                sigmaT += nullCollision;

                // Calculate scattering distance
                float scatterDistance = -log(Rnd(seed)) / sigmaT;
                float scatterDistanceFromCamera = (volumeNear + scatterDistance);

                // If we have multiple volumes we have to choose the closest scattering distance, so check if the new scattering distance
                // is smaller than the previous ones, then save the values
                if (scatterDistanceFromCamera < closestScatterDistanceFromCamera && pathLengthThroughVolume > 0.0f && pathLengthThroughVolume > scatterDistance)
                {
                    finalSigmaT = sigmaT;
                    finalColor = volume.Color;
                    finalG = volume.G;
                    finalNullCollision = nullCollision;
                    finalPathLengthThroughVolume = pathLengthThroughVolume;

                    closestScatterDistanceFromCamera = scatterDistanceFromCamera;

                    // Light sampling
                    IntersectRayAABB(payload.RayOrigin + (closestScatterDistanceFromCamera * payload.RayDirection), dirToLight, volume.Aabb, hitPosNear, hitPosFar);
            
                    hitPosNear = payload.RayOrigin + (closestScatterDistanceFromCamera * payload.RayDirection);

                    float volumeWidth = length(hitPosFar - hitPosNear);

                    finalVolumeWidth = volumeWidth;
                }
            }

            // If scattering occured scatter inside a volume
            if (closestScatterDistanceFromCamera < FLT_MAX)
            {
                // Null collision (only for heterogenous volumes)
                if (finalNullCollision / finalSigmaT > Rnd(seed))
                {
                    payload.RayOrigin = payload.RayOrigin + (closestScatterDistanceFromCamera * payload.RayDirection);
                    continue;
                }

                // New values
                payload.RayOrigin = payload.RayOrigin + (closestScatterDistanceFromCamera * payload.RayDirection);

                // Absorption
                rayQueryEXT query;
		        rayQueryInitializeEXT(query, topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, payload.RayOrigin, 0.00001f, dirToLight, 10000.0f);
		        rayQueryProceedEXT(query);
		        if (rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT)
		        {
			        canHit = false;
		        }
                
                curWeight *= finalColor;
                if (canHit)
                {
                    float phase = EvaluateHenyeyGreenstein(finalG, payload.RayDirection, dirToLight);
    
                    //hitValue += curWeight * phase * (envColor.xyz / envColor.w) * exp(-finalSigmaT * finalVolumeWidth) * BalanceHeuristic(envColor.w, phase);
                    hitValue += curWeight * phase * (envColor.xyz / envColor.w) * exp(-finalSigmaT * finalVolumeWidth);
                }

                payload.RayDirection = SampleHenyeyGreenstein(finalG, payload.RayDirection, vec2(Rnd(seed), Rnd(seed)));
                
                payload.LastEvent = LAST_EVENT_VOLUME;
            }
            // scattering didn't occur, scatter on surface
            else
            {
                payload.HitValue = vec3(0.0f);

                traceRayEXT(
                    topLevelAS,        // acceleration structure
                    rayFlags,          // rayFlags
                    0xFF,              // cullMask
                    0,                 // sbtRecordOffset
                    0,                 // sbtRecordStride
                    0,                 // missIndex
                    payload.RayOrigin,     // ray origin
                    tMin,              // ray min range
                    payload.RayDirection,  // ray direction
                    tMax,              // ray max range
                    0                  // payload (location = 0)
                );
                
                hitValue += payload.HitValue * curWeight;
                curWeight *= payload.Weight;
            }

            // Russian roulette based on ray color
            float p = min(max(curWeight.x, max(curWeight.y, curWeight.z)), 1.0f);
            if(Rnd(payload.Seed) >= p)
                break;  // paths with low throughput that won't contribute
            curWeight /= p;
        }

        // Eliminate caustics
#ifdef USE_CAUSTICS_SUPPRESION
        const float maxLuminance = push.CausticsLuminance;
        float lum = dot(hitValue, vec3(0.212671f, 0.715160f, 0.072169f));
        if(lum > maxLuminance)
        {
            hitValue *= maxLuminance / lum;
        }
#endif

        finalHitValue += hitValue;

        seed = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x + payload.Seed;
        payload.Seed = PCG(seed);

    }
    finalHitValue /= float(samplesAccumulated);

    // don't save it if final hit value is nan or inf (they may happen on refraction due to fresnel not being a complex equation but a simplification)
    if (!isinf(finalHitValue.x) && !isinf(finalHitValue.y) && !isinf(finalHitValue.z) && !isnan(finalHitValue.x) && !isnan(finalHitValue.y) && !isnan(finalHitValue.z))
    {
        if (push.Frame > 0)
        {
            float a  = 1.0f / float(push.Frame + 1);
            vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
            imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(oldColor, finalHitValue, a), 1.f));
        }
        else
        {
            imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalHitValue, 1.f));
        }
    }
}