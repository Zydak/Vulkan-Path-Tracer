#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_scalar_block_layout : enable

#include "raycommon.glsl"

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;
layout(set = 0, binding = 8) buffer DOFUniform { float dof; };
layout(set = 0, binding = 12, scalar) buffer Volumes { Volume uVolumes[]; };
layout(set = 1, binding = 0) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

void main()
{
    uint seed = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x + int(clockARB());
    payload.Seed = PCG(seed);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin    = uni.ViewInverse * vec4(0, 0, 0, 1);
    vec4 target    = uni.ProjInverse * vec4(d.x, d.y, 1, 1);
    vec3 direction = vec3(uni.ViewInverse * vec4(normalize(target.xyz), 0.0f));

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.00001f;
    float tMax     = 10000.0f;

    vec3 finalHitValue = vec3(0);

    payload.HitValue = vec3(0.0);
    payload.Depth = 0;
    payload.RayOrigin = origin.xyz;
    payload.RayDirection = direction;
    payload.Weight = vec3(0.0);
    payload.MissedAllGeometry = false;

    if (gl_LaunchIDEXT.xy == (gl_LaunchSizeEXT.xy / 2))
    {
        rayQueryEXT query;
		rayQueryInitializeEXT(query, topLevelAS, rayFlags, 0xFF, origin.xyz, tMin, direction, tMax);
		rayQueryProceedEXT(query);
		if (rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT)
		{
            float prevDof = dof;
			dof = rayQueryGetIntersectionTEXT(query, true);
		}
    }

    vec3 curWeight = vec3(1);
    vec3 hitValue  = vec3(0);

    int samplesAccumulated = 0;
    
    const vec3 camRight = vec3(uni.ViewInverse[0][0], uni.ViewInverse[1][0], uni.ViewInverse[2][0]);
    const vec3 camUp = vec3(uni.ViewInverse[0][1], uni.ViewInverse[1][1], uni.ViewInverse[2][1]);
    for (int i = 0; i < pcRay.SamplesPerFrame; i++)
    {
        samplesAccumulated++;
        ivec2 outputImageSize = imageSize(image);
        payload.HitValue = vec3(0.0);
        payload.Depth = 0;

        // Applying small jitter for anti aliasing
        vec2 antiAliasingJitter = RandomPointInCircle(payload.Seed) * 0.5f / outputImageSize * pcRay.AliasingJitter;
        vec3 directionCopy = direction;
        directionCopy += camRight * antiAliasingJitter.x + camUp * antiAliasingJitter.y;
        directionCopy = normalize(directionCopy);

        vec3 focalPoint = origin.xyz + directionCopy * pcRay.FocalLenght;
        vec2 jitter = RandomPointInCircle(payload.Seed) * pcRay.DoFStrenght / 500.0f;
        payload.RayOrigin = origin.xyz + camRight * jitter.x + camUp * jitter.y;

        payload.RayDirection = normalize(focalPoint - payload.RayOrigin);
        payload.Weight = vec3(0.0);

        vec3 curWeight = vec3(1);
        vec3 hitValue  = vec3(0);

        for(; payload.Depth < pcRay.MaxDepth; payload.Depth++)
        {
            float closestScatterDistanceFromCamera = FLT_MAX;
            float closestScatterDistance = 0.0;
            float finalVolumeNear = 0.0f;
            float finalVolumeFar = 0.0f;
            float finalPathLengthThroughVolume = 0.0f;
            float finalScatteringCoefficient = 0.0f;
            float finalAbsorptionCoefficient = 0.0f;
            vec3 finalColor = vec3(0.0f);
            float finalG = 0.0f;

            // Check at what distance the closest geometry is
            float closestGeometry = -1.0f;
            rayQueryEXT query;
		    rayQueryInitializeEXT(query, topLevelAS, rayFlags, 0xFF, payload.RayOrigin, tMin, payload.RayDirection, tMax);
		    rayQueryProceedEXT(query);
		    if (rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT)
		    {
		        closestGeometry = rayQueryGetIntersectionTEXT(query, true);
		    }

            for (int i = 0; i < pcRay.VolumesCount; i++)
            {
                Volume volume = uVolumes[i];
                vec3 hitPosNear;
                vec3 hitPosFar;
                IntersectRayAABB(payload.RayOrigin, payload.RayDirection, volume.Aabb, hitPosNear, hitPosFar);
            
                bool isInside = IsInsideAABB(payload.RayOrigin, volume.Aabb);
                if (isInside)
                    hitPosNear = payload.RayOrigin;
                float volumeWidth = length(hitPosFar - hitPosNear);

                float volumeNear = -1.0f;
                float volumeFar = -1.0f;
                if (hitPosNear != vec3(-1.0f))
                {
                    volumeNear = length(hitPosNear - payload.RayOrigin);
                }
                if (hitPosFar != vec3(-1.0f))
                {
                    volumeFar = length(hitPosFar - payload.RayOrigin);
                }

                float pathLengthThroughVolume = 0.0f;
                if (volumeNear != -1.0f && closestGeometry != -1.0f)
                {
                    // Geometry is in front of the volume
                    if (volumeNear > closestGeometry)
                    {
                        pathLengthThroughVolume = 0.0f;
                    }
            
                    // Geometry is splitting the volume
                    else if (volumeFar > closestGeometry)
                    {
                        pathLengthThroughVolume = closestGeometry - volumeNear;
                    }
                
                    // Volume is in front of the geometry
                    else if (volumeFar < closestGeometry)
                    {
                        pathLengthThroughVolume = volumeWidth;
                    }
                }
                else if (closestGeometry == -1.0f && volumeNear != -1.0f) // Volume in front of the geometry since there is no geometry
                {
                    pathLengthThroughVolume = volumeWidth;
                }

                float sigmaT = volume.ScatteringCoefficient + volume.AbsorptionCoefficient;

                float scatterDistance = -log(Rnd(seed)) / sigmaT;
                float scatterDistanceFromCamera = (volumeNear + scatterDistance);

                if (scatterDistanceFromCamera < closestScatterDistanceFromCamera && pathLengthThroughVolume > 0.0f && pathLengthThroughVolume > scatterDistance)
                {
                    finalVolumeNear = volumeNear;
                    finalVolumeFar = volumeFar;
                    finalPathLengthThroughVolume = pathLengthThroughVolume;
                    finalScatteringCoefficient = volume.ScatteringCoefficient;
                    finalAbsorptionCoefficient = volume.AbsorptionCoefficient;
                    finalColor = volume.Color;
                    finalG = volume.G;

                    closestScatterDistance = scatterDistance;
                    closestScatterDistanceFromCamera = scatterDistanceFromCamera;
                }
            }

            // Scatter inside a volume
            if (finalPathLengthThroughVolume > closestScatterDistance)
            {
                float sigmaT = finalScatteringCoefficient + finalAbsorptionCoefficient;

                curWeight *= vec3(finalScatteringCoefficient / sigmaT) * finalColor;

                vec3 newDir = SampleHenyeyGreenstein(finalG, payload.RayDirection, vec2(Rnd(seed), Rnd(seed)));

                payload.RayOrigin = payload.RayOrigin + ((finalVolumeNear + closestScatterDistance) * payload.RayDirection);

                payload.RayDirection = newDir;
            }
            // Scatter on surface
            else
            {
                traceRayEXT(
                    topLevelAS,        // acceleration structure
                    rayFlags,          // rayFlags
                    0xFF,              // cullMask
                    0,                 // sbtRecordOffset
                    0,                 // sbtRecordStride
                    0,                 // missIndex
                    payload.RayOrigin,     // ray origin
                    tMin,              // ray min range
                    payload.RayDirection,  // ray direction
                    tMax,              // ray max range
                    0                  // payload (location = 0)
                );
                
                hitValue += payload.HitValue * curWeight;
                curWeight *= payload.Weight;
            }

            float p = min(max(curWeight.x, max(curWeight.y, curWeight.z)) + 0.001, 1.0f);
            if(Rnd(payload.Seed) >= p)
                break;  // paths with low throughput that won't contribute
            curWeight /= p;
        }

        // Eliminate caustics
#ifdef USE_CAUSTICS_SUPPRESION
        const float maxLuminance = pcRay.CausticsLuminance;
        float lum = dot(hitValue, vec3(0.212671f, 0.715160f, 0.072169f));
        if(lum > maxLuminance)
        {
            hitValue *= maxLuminance / lum;
        }
#endif

        finalHitValue += hitValue;

        seed = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x + payload.Seed;
        payload.Seed = PCG(seed);

        //if (payload.MissedAllGeometry)
		//{
		//	break;
		//}

    }
    finalHitValue /= float(samplesAccumulated);

    if (!isinf(finalHitValue.x) && !isinf(finalHitValue.y) && !isinf(finalHitValue.z) && !isnan(finalHitValue.x) && !isnan(finalHitValue.y) && !isnan(finalHitValue.z))
    {
        if (pcRay.Frame > 0)
        {
            float a  = 1.0f / float(pcRay.Frame + 1);
            vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
            imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(oldColor, finalHitValue, a), 1.f));
        }
        else
        {
            imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalHitValue, 1.f));
        }
    }
}