<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEE - Vulkan Path Tracer</title>
    <link rel="stylesheet" href="feature-style.css">
    
    <!-- MathJax for LaTeX support -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>
<body>
    <div class="container">
        <header class="main-header">
            <h1>Next Event Estimation</h1>
            <a href="../index.html" class="back-link">‚Üê Back to Home</a>
        </header>
        
        <div class="feature-content">
            
            <div class="chapter-content">
                <div class="centered-container">
                    <img src="../Images/BreakfastRoom.png" width="100%">
                </div>
            </div>

            <h2>Naive Path Tracing</h2>
            <div class="chapter-content">
                <p>
                    Naive path tracing (sometimes called brute force), is a type of path tracing, where rays shot from the camera bounce around the scene until they loose all energy, lights are discovered by pure chance, no shortcuts or approximations are used. It can compute global illumination very accurately, but I've hit a limit on this technique fairly soon in the development.
                </p>
                <p>
                    Consider what happens if I'd place sun in the scene, it's really far away, so it appears small, and it's insanely bright. Probability of rays randomly bouncing around and hitting the sun is marginal, and brightness is measured in thousands if not millions. So variance will be through the roof, and that's exactly what happens. The image below is 100K samples per pixel.
                </p>
                <div class="centered-container">
                    <img src="../Images/BreakfastNaive100K.png" width="100%">
                    <p>
                        
                    </p>
                </div>
            </div>

            <h2>Next Event Estimation</h2>
            <div class="chapter-content">
                <p>
                    So to reduce the amount of noise I decided to implement <b>NEE</b> (next event estimation), so explicitly sampling light sources at each bounce to estimate direct lighting from them. It's done by shooting a shadow ray from the surface point to a sampled light source and checking for occlusion. If surface point is unoccluded, direct lighting is estimated.
                </p>
            </div>

            <h2>Multiple Importance Sampling</h2>
            <div class="chapter-content">
                <p>
                    To combine current BSDF importance sampling with light sampling I implemented MIS according to <a href="https://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Veach95.pdf">Optimally Combining Sampling Techniques for Monte Carlo Rendering</a>.
                </p>
                <p>
                    I take two samples, one from each sampling strategy:
                    <ul>
                        <li>
                            <strong>BSDF / Phase function Sample</strong>
                            <ul>
                                <li>Direction: $\omega_\text{bsdf}$</li>
                                <li>BSDF evaluation: $f(\omega_\text{bsdf})$</li>
                                <li>PDF evaluation: $p_\text{bsdf}(\omega_\text{bsdf})$</li>
                                <li>Additional PDF evaluation in the direction of light: $p_\text{bsdf}(\omega_\text{light})$</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Light Sample</strong>
                            <ul>
                                <li>Direction: $\omega_\text{light}$</li>
                                <li>BSDF evaluation: $f(\omega_\text{light})$</li>
                                <li>PDF evaluation: $p_\text{light}(\omega_\text{light})$</li>
                                <li>Additional PDF evaluation in the direction of BSDF: $p_\text{light}(\omega_\text{bsdf})$</li>
                            </ul>
                        </li>
                    </ul>
                </p>
                <p>
                    My MIS weights are computed using power heuristic with $\beta = 2$:

                    $$
                    \begin{gather*}
                    w_\text{light} = \frac{p_\text{light}(\omega_\text{light})^2}{p_\text{light}(\omega_\text{light})^2 + p_\text{bsdf}(\omega_\text{light})^2}\\
                    w_\text{bsdf} = \frac{p_\text{bsdf}(\omega_\text{bsdf})^2}{p_\text{bsdf}(\omega_\text{bsdf})^2 + p_\text{light}(\omega_\text{bsdf})^2}
                    \end{gather*}
                    $$

                    Explicitly sampling lights is happening at every scattering event, be that a surface or a volume, where the weighted contribution of the sampled light is added to the emitted light.

                    $$
                    L_e = L_e + w_\text{light} \cdot \frac{f(\omega_\text{light}) \cdot \text{light}_\text{emission}}{p_\text{light}(\omega _\text{light})}
                    $$

                    When a BSDF sampled ray hits the light by chance, the contribution of the light also has to be weighted to avoid double counting. This happens in <code>Miss.slang</code> when ray hits the environment map. For now NEE works only for environment map, sampling mesh lights is not implemented yet.

                    $$
                    L_e = L_e + w_\text{bsdf} \cdot \text{light}_\text{emission}
                    $$

                    This approach ensures that both sampling strategies contribute appropriately while avoiding double counting.
                </p>
                <p>
                    Also, because there are volumes in the scene, transmittance must be taken into account. That is, how much light is blocked by a volume in the way.
                </p>
                <p>
                    For simple homogeneous volumes, it can be computed analytically with Beer-Lambert law: $T = e^{-\sigma_t \cdot t}$.
                </p>
                <p>
                    For heterogeneous volumes, it has to be integrated numerically with delta tracking. So when shadow ray is shot towards the light, it has to march through the volume and estimate transmittance at each step. This is done in <code>Volume.slang</code> based on the ratio between density at a point and a majorant.
                </p>
                <pre>
                    <code>
transmittance *= 1.0f - (densityAtAPoint / majorantDensity);
                    </code>
                </pre>
                <p>
                    Light emission is then multiplied by the transmittance before being added to the emitted light.
                    $$
                    \text{light}_\text{emission}^\prime = \text{light}_\text{emission} \cdot T
                    $$
                </p>
            </div>

            <h2>Sampling Lights</h2>
            <div class="chapter-content">
                <p>
                    The method of sampling the direction to the light source and evaluating it's PDF is different for every type of light source.
                </p>

                <h3>Environment Map</h3>
                <p>
                    Since environment map is conceptually just a big sphere around the scene, I first tried to uniformly sample it. So direction is random vector on a sphere, and PDF is $\frac{1}{4 \pi}$.
                </p>
                <p>
                    But, uniform sampling won't make much difference, chance of sampling small bright spot on a huge 4K texture will be just as small as the chance for a ray to randomly bounce into it. It's an improvement, of course, but still not good enough. Image below has 100K samples per pixel, it has somewhat less noise than naive version, but it's still a lot of noise nonetheless. So in order to fix that, I use importance sampling. That will steer sampled directions into the brighter areas of environment map.
                </p>
                <div class="centered-container">
                    <img src="../Images/BreakfastUniformNEE100K.png" width="100%" />
                </div>
                <p>
                    So to importance sample the environment map, I decided to use <a href="https://en.wikipedia.org/wiki/Alias_method">Alias Method</a>. It has O(1) time complexity so it's great for performance, and it works really well. The only drawback is that it requires precomputation and some extra memory (additional 2 floats per pixel), but that's not a big deal. I create a 2D alias table for the environment map in <code>PathTracer.cpp</code> when scene is loaded.
                </p>

                <h3>Emissive Meshes</h3>
                <p>
                    Sampling of emissive meshes is not yet supported. Only Environment Map NEE works properly.
                </p>
            </div>

            <h2>Results</h2>
            <div class="chapter-content">
                <p>
                    I don't think I have to point out the difference in noise. All images have 25K samples per pixel taken. First one represents naive path tracing. Second one is NEE with uniformly sampled environment map. And third one is NEE with importance sampled environment map.
                </p>
                <div class="centered-container">
                    <img src="../Images/BreakfastNaive25K.png" width="100%" />
                </div>
                <div class="centered-container">
                    <img src="../Images/BreakfastUniformNEE25K.png" width="100%" />
                </div>
                <div class="centered-container">
                    <img src="../Images/BreakfastImportanceNEE25K.png" width="100%" />
                </div>

                <p>
                    If you look closely at the last image, you'll see that there are still really bright pixels spread out in the image. These are called <b>fireflies</b>. They appear because even with NEE, it's still possible for ray to stumble upon really bright light source by bouncing randomly in the scene. And since the emission value of those is very high, the pixel is very bright. They do not contribute much to the final image and are mostly just annoying noise, so to get rid of them I set maximum luminance value which pixel can have, and if it exceeds it, it gets scaled down. For this image max luminance I used was 20, so that it doesn't interfere with scene lighting but affects the fireflies.
                </p>
                <pre>
                    <code>
float luminance = dot(pixelValue, float3(0.212671f, 0.715160f, 0.072169f));
float scale = MaxLuminance / max(luminance, MaxLuminance);
pixelValue *= scale;
                    </code>
                </pre>

                <div class="image-row">
                    <div class="centered-container">
                        <img src="../Images/BreakfastFireflies.png" width="100%" />
                        <p>Unclamped Luminance</p>
                    </div>
                    <div class="centered-container">
                        <img src="../Images/BreakfastFirefliesDeleted.png" width="100%" />
                        <p>Clamped Luminance</p>
                    </div>
                </div>

                <p>
                    Scattering inside volumes also doesn't take an eternity to converge now, the only difference here is that instead of evaluating the surface BSDF, I evaluate the phase function. Both images below are 25K samples per pixels.
                </p>
                <div class="image-row">
                    <div class="centered-container">
                        <img src="../Images/SuzanneRoomNaive25K.png" width="100%" />
                        <p>Naive</p>
                    </div>
                    <div class="centered-container">
                        <img src="../Images/SuzanneNEEImportance25K.png" width="100%" />
                        <p>NEE with Importance Sampling</p>
                    </div>
                </div>
            </div>

        </div>
        <a href="AntiAliasing.html" class="back-link">Next Section</a>
    </div>
</body>
</html>
